// -*- coding: utf-8, tab-width: 2 -*-

import is from 'typechecks-pmb';
import mustBe from 'typechecks-pmb/must-be';
import getOwn from 'getown';

import nodeModuleMeta from '../../package.json';
import spRes from '../resUtil/simplePassiveResource';
import claimStageFacts from '../resUtil/bundle/claimStageFacts';



const deferUpdProp = 'deferPkgListUpdate';

function rewriteUrlProtos(origUrl) {
  let u = mustBe.nest('URL', origUrl);

  u = u.replace(/^ppa:(\S+)/, 'http://ppa.launchpad.net/$1/%{distro}');
  // Why no SSL? -> https://bugs.launchpad.net/launchpad/+bug/1473091
  // Discussion of possible attack vectors against unencrypted
  // downloading of signed packages:
  // https://github.com/nodesource/distributions/issues/71
  // (2020-07-05: Mostly, hiding new updates for as long as the
  // old signature is still valid.)

  return u;
}


async function hatch(initExtras) {
  const parBun = initExtras.getLineageContext().parentBundle;
  const bundleParamMustBe = parBun.makeParamPopper().mustBe;
  const renderOVT = (function compile() {
    const b = 'osVersion';
    const d = bundleParamMustBe('fal | dictObj', b, false);
    const r = /%\{([\w\-]+)\}/g;
    function w(m, k) { return m && mustBe.nest(`${b}.${k}`, getOwn(d, k)); }
    return function renderOsVersionTemplate(s) { return s.replace(r, w); };
  }());

  const res = this;
  const mustFact = mustBe.tProp(res.typeName + ' prop ',
    await res.toFactsDict({ acceptPreliminary: true }));
  const debLines = ['# generated by ' + nodeModuleMeta.name + '\n'];
  const dists = mustFact('nonEmpty ary', 'dists');
  const compo = mustFact('nonEmpty ary', 'components');
  const src = mustFact('bool', 'src');
  mustFact('nonEmpty ary', 'debUrls').map(rewriteUrlProtos).forEach((url) => {
    mustBe.near('dists', dists).forEach((dist) => {
      mustBe.nest('dist', dist);
      const debLn = renderOVT([url, dist, ...compo].join(' ') + '\n');
      debLines.push('deb     ' + debLn);
      if (src) { debLines.push('deb-src ' + debLn); }
    });
  });

  const path = '/etc/apt/sources.list.d/ubborg.' + res.id + '.list';
  await res.needs('admFile', {
    path,
    mimeType: 'text/plain',
    content: debLines,
  });
}



async function finalizePlan(initExtras) {
  await claimStageFacts(initExtras, function claims(facts) {
    if (!facts[deferUpdProp]) { return; }
    return { deferredDebPkgs: { updatePkgLists: true } };
  });
}


const recipe = {
  typeName: 'debPkgRepo',
  idProps: ['name'],
  defaultProps: {
    state: 'enabled',
    [deferUpdProp]: true,
    src: true,    // whether to add deb-src as well.
    dists: ['%{codename}'],
  },
  acceptProps: {
    debUrls: true,
    components: true,
    primaryKeyId: true,

    trustedLocalAptKeyRingName: true,
    // ^- Provide a repo key using a pre-made, already-converted
    //    `/etc/apt/trusted.gpg.d/${keyRingName}.gpg` that we can just copy.
    keyUrl: true,
    keyVerify: true,
  },
  promisingApi: {
    hatch,
    finalizePlan,
  },
};

const spawnCore = spRes.makeSpawner(recipe);

const simpleStates = [
  recipe.defaultProps.state,
  'absent',
];


async function plan(spec) {
  if (is.str(spec)) { return plan.call(this, { name: spec }); }
  const { state } = spec;
  mustBe([['oneOf', [undefined, ...simpleStates]]], 'state')(state);
  const res = await spawnCore(this, spec);
  return res;
}


export default {
  plan,
  recipe,
};
